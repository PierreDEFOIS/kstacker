mail_address: "herve.lecoroller@lam.fr"
#mail_address: "herve.lecoroller"
job_name: 'orb15' #Name prefix of your job's name on the cluster. For example for the brut your job name will be {job_name}_images_brute

profiles_walltime: "04:00:00" # walltime to create the profiles (load_images_profile.sh)
brute_walltime: "24:00:00" # walltime for brute force on each core (image_brute.sh)
grid_walltime: "02:00:00" # walltime for combining the grid (create_grid.sh)
reopt_walltime: "05:00:00" # walltime for reoptimization (gradient_descent.sh)
mess_walltime: "02:00:00" # walltime for K-Mess_teq or K-Mess

Tstar: 5800. # temperature of the star in Kelvin
Rstar: 1.2 # Radius of the star in solar radius
fextra: 0.5 # fextra=0.1 percentage of internal heating added to the Teq
Albedo: 0.3 # Albedo of the planet

noise_prof: 'yes' # to compute the noise and background profile (with noise_profile_snr_herve.py)
snr_plot: 'yes' # to compute the snr plots (with noise_profile_snr_herve.py)

remove_noisy: 'no' # Default='weakly'; To reject bad images: 'no' or 'weakly' or 'strongly'; weakly (: coef of 1.4); See demo of herve logbook

p: 16   # number of images for a run, or number of images added to a previous run
p_prev: 0   # number of previous images used for a run on which other p images will be added, for a new run put 0
total_time: 0  # total time for all the observations in years for simulations, put 0 for real observations and fill the time variable
n: 100   # size of the images nxn
upsampling_factor: 5  # upsampling factor for the aperture integration

#time: "0.0+0.0054757015742642025+0.010951403148528405+0.01642710472279261+0.019164955509924708+0.02190280629705681+0.024640657084188913+0.02737850787132101+0.030116358658453114+0.03285420944558522+0.03559206023271732+0.04106776180698152+0.04380561259411362+0.04654346338124572+0.049281314168377825+0.09308692676249145" # time (years) of each observation for p+p_prev images; Origin of dates : JD:  2458627.5 = 2019-05-24

time: "0.0+0.03+0.06+0.09+0.12+0.15+0.18+0.21+0.24+0.27+0.3+0.33+0.36+0.39+0.42+0.45" # time (years) of each observation for p+p_prev images; Origin of dates : JD:  2458627.5 = 2019-05-24; times of the injected planet in NEAR data (cover all the orbit out of the half part of the mask)

remove_planet: 'no' #yes or no ; Remove planet from the noise and background computation (noise_profile_snr_herve)
planet_coord: "(145:105)+(146:105)+(147:104)+(148:105)+(154:106)+(157:106)+(156:106)+(154:104)+(153:105)" # !! pixels python coordinates here; KEEP THIS FORMAT (no spaces, etc.)

remove_box: "20.0+20.0+20.0+20.0" #size of the exclusion box if remove_planet='yes'. In pixels.
# Each number is a variation from the 01 Janvier 2000 : write the times spaced by a + sign

work_dir: "~/data/kstacker/near_alphacenA_b_fast"
images_dir: "images_planet_injected_maskzeros"   # folder where to load the images
grid_dir: "brute_grid"   # folder where to save the grid and the values of signals and noises after the brute force
values_dir: "values"   # folder where to save the SNR and parameters of the q best orbits, the q final images and orbits
profile_dir: "profiles"   # folder where to save and load the background and noise profiles
single_plot: 'yes'    # yes or no to display the positions of the planet in each frame for the q best solutions
adding: 'no'   # yes or no if you want to add new p images to a previous run. WARNING : use the exact same grid as the previous run.

q: 100      # number of maxima that will be reoptimized by the gradient descent algorithm (default=100)
dist: 1.34    # distance of the star  (in parsec)(used to project the orbits on the CCD and in the convertion a.u. in pixels)
wav: 2e-6
#wav: 4.4e-6   # wavelength of observation (in meter)(used only to define the size of the circle for integration of the flux); diameter = 2 X FWHM-PSF = 2 x 1.028 x lambda /d =>  pr 11.25e-6 microns = 12.75 pixels (But in the PSF in nights_inj...as about 6 pixels. So I divided 11.25/2 to get 6 pixels)
d: 8.2        # diameter of the primary miror (in meter)(used only to define the size of the circle for integration of the flux)
resol: 45.6   # plate-scale in marcsec/pixel (used to define the size of the circle for integration of the flux,and convert a.u. in pixels )

r_mask: 13.    # radius of the coronagraphic mask (in pixels) (very important: put at zero all the values in this circle; put also a mask on the images by using mask_images.py (for visualisation); size of r_mask(a.u.) = r_mak(pixels)/(distance(PC)x12,25x10^-3))
r_mask_ext: 49. # radius of the exterior mask (in pixels). Put at zero values at larger radius (use in noise_profile_snr_herve.py)

mask_value: 0. # Put the min value of the speckles. Default 0.

m0: 1.133       # mass of the star in solar mass

#orbital parameters to plot the SNRs curves (used to determine the grid steps); it can be the orbital parameters of a planet or not

#Values of orbit_1 for DC dryrun

a_init: 1.5 # expectd alphacenAb candidate at 1.1 au
e_init: 0.55
t0_init: -0.55
omega_init: 0.
i_init: 1.13
theta_0_init: 0.

a_min: 0.9    # minimum semi-major axis (in a.u.)# At this distance (0.9 au), half of the integration circle is on the mask; expectd alphacenAb candidate at 1.1 au
a_max: 1.75   # maximum semi-major axis (in a.u.)
Na: 6 #
Sa: 2        #Number of time the range of a is splitted in the temporary files (Na/Sa must be an integer and superior or equal to 2) If you don't use the temporary files put it at 0

e_min: 0.    # minimum eccentricity
e_max: 0.9    # maximum eccentricity
Ne: 4
Se: 2         #Number of time the range of e is splitted in the temporary files (Ne/Se must be an integer and superior or equal to 2) If you don't use the temporary files put it at 0

t0_min: -2.1  # minimum epoch at perihelion in years (this is in fact the maximum but there is a minus sign)
t0_max: -0.    # maximum epoch at perihelion in years (this is in fact the minimum but there is a minus sign)
Nt0: 8 # number of steps for the epoch at perihelion  (use plot_SNR.py to determine this value)

omega_min: -3.14   # minimum longitude of the ascending node in rad
omega_max: 3.14    # maximum longitude of the ascending node in rad
Nomega: 6
Somega: 2       #Number of time the range of omega is splitted in the temporary files (Nomega/Somega must be an integer and superior or equal to 2) If you don't use the temporary files put it at 0

i_min: 0.      # minimum inclination in rad
i_max: 3.    # maximum inclination in rad
#Ni :  64
Ni: 4
Si: 2          #Number of time the range of i is splitted in the temporary files (Ni/Si must be an integer and superior or equal to 2) If you don't use the temporary files put it at 0

theta_0_min: -3.14   # minimum argument of the periapsis in rad
theta_0_max: 3.14    # maximum argument of the periapsis in rad
Ntheta_0: 6
Stheta_0: 2     #Number of time the range of theta_0 is splitted in the temporary files (Ntheta_0/Stheta0 must be an integer and superior or equal to 2) If you don't use the temporary files put it at 0

xmin: -3.    # minimum value on x axis for the plot of the orbits (in a.u.) ex: xmin=-18.
xmax: 3.     # maximum value on x axis for the plot of the orbits (in a.u.) ex: xmax=18.
ymin: -3.    # minimum value on y axis for the plot of the orbits (in a.u.) ex: ymin=-18.
ymax: 3.     # maximum value on y axis for the plot of the orbits (in a.u.) ex: ymax=18.

ncores: 1    # number of cores to parallelize the simulations (regarding the number of steps for the epoch at perihelion) On each core t0 is fixed, and we test all the others orbital parameters (a,e,omega,i,teta_0)
nchunks: 2   # number of chunks to split the grid (even with one core this limits the amout of memory)
